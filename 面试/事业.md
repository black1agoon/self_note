## CDN的全称是Content Delivery Network
* 内容分发网络
* CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。
* 关键技术主要有内容存储和分发技术
---
## DNS (Domain Name System)
* 将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网
---
## web前端性能优化：
* 1.图片懒加载, 使用sprite精灵图
* 2.将代码打包压缩
* 3.减少dom操作
* 4.减少首屏的加载时间
* 5.减少http请求，合理设置 HTTP缓存
* 6.使用浏览器缓存
* 7.CSS放在页面最上部，javascript放在页面最下面
* 8.减少浏览器回流(Reflow)和重绘(Repaint)
---
## HTTP 请求方法
- get: 参数通过URL传递, 从服务器获取资源
- head: 
    - HEAD方法：与GET方法的行为很类似，但服务器在响应中只返回首部，不返回实体的主体部分。这就允许客户端在未获取实际资源的情
    - 况下，对资源的首部进行检查，使用HEAD，我们可以更高效的完成以下工作：
    - 在不获取资源的情况下，了解资源的一些信息，比如资源类型；
    - 通过查看响应中的状态码，可以确定资源是否存在；
    - 通过查看首部，测试资源是否被修改；

- trace: 会在目的服务器端发起一个“回环”诊断，我们都知道，客户端在发起一个请求时，这个请求可能要穿过防火墙、代理、网关、或者其它的一些应用程序。这中间的每个节点都可能会修改原始的HTTP请求，TRACE方法允许客户端在最终将请求发送服务器时，它变成了什么样子。由于有一个“回环”诊断，在请求最终到达服务器时，服务器会弹回一条TRACE响应，并在响应主体中携带它收到的原始请求报文的最终模样。这样客户端就可以查看HTTP请求报文在发送的途中，是否被修改过了。

- options: 用于获取当前URL所支持的方法。

- post: 向服务器提交表单信息

- put: 向服务器写入文档, PUT 方法的语义就是让服务器用请求的主体部分来创建一个由所请求的URL命名的新文档, 如果那个URL已经存在的话, 就用这个主体来替换它

- patch: 是对put方法的补充, 用来对已知资源进行局部更新

- delete: 删除请求 url 指定的资源
---
##　HTTPS和HTTP的区别主要如下：

* 1. https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。

* 2. http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

* 3. http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

* 4. http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
---

## https: http + SSL
* SSL: 是为网络通信提供安全及数据完整性的一种安全协议。

---

## HTTPS 通信过程
* 1. 客户端对服务器发起https请求 连接到服务器443端口.
* 2. 服务器采用的https有一套 ca 数字证书 包含了 公钥 和 私钥
* 3. 服务器将公钥证书传送给客户端，证书中包含了很多信息，比如证书的颁发机构，过期时间，网址，公钥等.
* 4. 客户端解析证书，验证 证书公钥是否有效，证书是否过期等，如有异常则会弹出警告信息。 证书没问题之后， 会随机生成随机值， 然后使用 证书中的公钥对这个随机值 进行非对称加密.
* 5. 将非对称加密后的随机值传送到服务器
* 6. 服务器使用私钥进行非对称解密，得到客户端产生的随机值， 然后把将要返回给客户端的内容进行对称加密， 然后发送给客户端
* 7. 客户端拿到加密后的内容后用之前生产的随机值进行对称解密， 最后获取到内容。
---
## HTTP 完整请求流程
* 1. 客户端请求域名， 然后进行域名解析 转换成ip地址
* 2. 客户端拿到解析出来的 ip 地址后， 会进行 tcp 三次握手与服务器建立连接
* 3. 客户端向服务器发送请求
* 4. 服务器返回源代码给客户端
* 5. 客户端解析请求回来的源代码，并请求代码中的其他资源 如 静态资源图片, css, js 文件等。
* 6. 客户端进行页面渲染
* 7. web 服务器断开连接(四次握手), 有些特殊请求不断开

---

## URI: 统一资源标识符, 统一资源标识符，根据某一种规则将一个资源独一无二地标识出来。
## URL: 统一资源定位符, 统一资源定位符，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何定位这个资源。
## URN: 统一资源名, 统一资源名称。
## URL 和 URN 是 URI 的子集

- 统一资源标志符URI就是在某一规则下能把一个资源独一无二地标识出来。拿人做例子，假设这个世界上所有人的名字都不能重复，那么名字就是URI的一个实例，通过名字这个字符串就可以标识出唯一的一个人。现实当中名字当然是会重复的，所以身份证号才是URI，通过身份证号能让我们能且仅能确定一个人。那统一资源定位符URL是什么呢。也拿人做例子然后跟HTTP的URL做类比，就可以有：动物住址协议://地球/中国/浙江省/杭州市/西湖区/某大学/14号宿舍楼/525号寝/张三.人可以看到，这个字符串同样标识出了唯一的一个人，起到了URI的作用，所以URL是URI的子集。URL是以描述人的位置来唯一确定一个人的。在上文我们用身份证号也可以唯一确定一个人。对于这个在杭州的张三，我们也可以用：身份证号：123456789


---
## 什么是线程和进程?
- **进程** 是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。
- **线程** 与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。

- **区别** 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。

---

## 死锁 ？？？

---
## 深拷贝，浅拷贝区别
- **浅拷贝**：浅拷贝会在堆上创建一个新的对象，不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。
- **深拷贝** ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。

--- 
## 什么是序列化?什么是反序列化?
- **序列化**： 将数据结构或对象转换成二进制字节流的过程。序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。
- **反序列化**：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程


---
## 泛型
- **泛型**： 所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、创建对象时确定（即传入实际的类型参数，也称为类型实参）。
- **好处**
1. 使用泛型编写的程序代码
2. 多种数据类型执行相同的代码使用泛型可以复用代码。

---
## 什么是操作系统？
1. 操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。
2. 操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。 
3. 操作系统存在屏蔽了硬件层的复杂性。 操作系统就像是硬件使用的负责人，统筹着各种相关事项。
4. 操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。

---
## 进程有哪几种状态?
* **创建状态** ：进程正在被创建，尚未到就绪状态。
* **就绪状态** ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。
* **运行状态**：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。
* **阻塞状态**：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。
* **结束状态**：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。

---
## 什么是死锁
* **死锁** 描述的是这样一种情况：多个进程/线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于进程/线程被无限期地阻塞，因此程序不可能正常终止。
> ### 产生死锁的四个必要条件是什么?
1. 互斥：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。
2. 占有并等待：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。
3. 非抢占：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。
4. 循环等待：有一组等待进程 {P0, P1,..., Pn}， P0 等待的资源被 P1 占有，P1 等待的资源被 P2 占有，......，Pn-1 等待的资源被 Pn 占有，Pn 等待的资源被 P0 占有。
> ### 解决死锁的方法
解决死锁的方法可以从多个角度去分析，一般的情况下，有预防，避免，检测和解除四种。

1. **预防** 是采用某种策略，限制并发进程对资源的请求，从而使得死锁的必要条件在系统执行的任何时间上都不满足。

2. **避免** 则是系统在分配资源时，根据资源的使用情况提前做出预测，从而避免死锁的发生

3. **检测** 是指系统设有专门的机构，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。

4. **解除** 是与检测相配套的一种措施，用于将进程从死锁状态下解脱出来。