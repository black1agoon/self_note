## Cache-Control：
1. no-cache : 不直接使用缓存，始终向服务器发起请求

2. no-store : 禁止缓存任何响应，也就是说每次用户请求资源时，都会向服务器发送一个请求，每次都会下载完整的响应。

3. public ： 如果响应被标记为public，即使有关联的 HTTP 认证，甚至响应状态码无法正常缓存，响应也可以被缓存。

4. private : 浏览器可以缓存private响应，但是通常只为单个用户缓存，因此，不允许任何代理服务器对其进行缓存 。比如，用户浏览器可以缓存包含用户私人信息的 HTML 网页，但是 CDN 不能缓存。

5. max-age :  用来设置资源被缓存的最长时间(单位是秒)。


Etag: 客户端发送请求，服务端通过response header返回过来。 当客户端再次请求的时候 会将Etag通过if none match重新传给服务器。 （先比较文件修改时间是否一致）服务器根据 此时文件的etag做比较。相同则返回304， 不同则200


1.3 Last-Modified和Etag
从上面的解释可以看出，Cache-Control用于控制缓存和缓存时间，Last-Modified和Etag用于缓存过期时，与服务器做验证时使用，那么问题来了

有了Last-Modified为什么还需要Etag？
    1.Last-Modified的值单位为秒。如果服务资源在1秒内发生多次变更，那服务器通过秒级对比就没办法发现文件是否已经变更。
    2.一些特殊场景下，有些资源会被定时更新或者修改，但是其内容并未发生改变，而最后修改时间却在变化，导致客户端缓存定期失效，没有达到使用缓存的目的。
    3.服务器可能因为一些其他原因，其时间没有与代理服务器或客户端时间保持一致，因时间偏差，从而导致缓存失效。


有了Etag为什么还需要Last-Modified？
    1.Etag的值是服务器计算出的一串hash值，如果计算过程较复杂，比较消耗性能，那使用Last-Modified会比较合适
    2.如果获取某些文件的最后修改时间比较容易，而文件的变更频率也不高，那无疑使用Last-Modified更合适

ETag比较的是响应内容的特征值，而Last-Modified 比较的是响应内容的修改时间。这两个是相辅相成的。
服务器可以根据自己缓存机制的需要，选择ETag或者是Last-Modified来做缓存判断的依据，甚至可以两个同时参考。
Etag和Last-Modified同时存在时，服务器会优先判断Etag，如果Etag的值相同会继续判断Last-Modified，最后才决定是返回200还是304状态



## If-None-Match 请求首部
- 对应 ETag (响应首部)

## Cache-Control: no-cache / no-store => no-cache 和 no-store 用作控制缓存，被服务器通过响应头 Cache-Control 传递给客户端
- no-store 永远都不要在客户端存储资源，永远都去原始服务器去获取资源。
- no-cache 可以在客户端存储资源，每次都必须去服务端做新鲜度校验，来决定从服务端获取新的资源（200）还是使用客户端缓存（304）。也就是所谓的协商缓存。
- 相当于以下缓存头 Cache-Control: max-age=0, must-revalidate

